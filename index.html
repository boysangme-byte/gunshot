<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>ì•…ë ¹ì‚¬ëƒ¥ v11.3</title>
  <style>
    :root { --bg:#0a0014; --panel:#150b2c; --line:#3a2360; --text:#e9d7ff; --accent:#d080ff; --good:#73ffdf; --pink:#ff76d2; }
    *{ box-sizing:border-box }
    body{ margin:0; min-height:100vh; display:grid; place-items:center; background:radial-gradient(950px 650px at 70% 20%,#1a0038,var(--bg)); color:var(--text); font-family:"Noto Sans KR",system-ui,sans-serif }
    .stage{ position:relative; width:100%; max-width:960px }
    #game{ width:100%; aspect-ratio:16/9; background:#000; border:2px solid var(--line); border-radius:12px; display:block; touch-action:none }
    .title{ font-weight:900; font-size:20px; margin:12px 0 8px; color:var(--accent); text-shadow:0 0 8px var(--accent) }
    .hud{ display:flex; gap:12px; flex-wrap:wrap; font-size:14px }
    .hud > div{ background:#ffffff0c; border:1px solid var(--line); padding:6px 10px; border-radius:8px }
    .overlay{ position:absolute; inset:0; display:none; align-items:center; justify-content:center }
    .panel{ background:#120626ee; border:1px solid var(--line); border-radius:16px; padding:22px; text-align:center; box-shadow:0 10px 30px #0008 }
    .btn{ background:#2a1658; color:#fff; border:1px solid #5b3db3; padding:10px 16px; border-radius:10px; cursor:pointer }
    /* heat bar â€“ a bit lower */
    .heatbar { position:absolute; left:14px; right:14px; bottom:4px; height:8px; border-radius:6px; border:1px solid var(--line); background:#241542; display:none;}
    .heatfill { height:100%; border-radius:6px; background:linear-gradient(90deg,#7be7ff,#d080ff,#ff76d2); width:0%; }
    .heatlabel { position:absolute; bottom:18px; left:14px; font-size:12px; opacity:.8 }
    .overblink { animation: blink 0.6s linear infinite; }
    @keyframes blink { 50%{ opacity:.35 } }
  </style>
</head>
<body>
  <div class="stage">
    <div class="title">ğŸ® ì•…ë ¹ì‚¬ëƒ¥ <small style="opacity:.7">v11.3</small></div>
    <canvas id="game"></canvas>

    <div class="hud">
      <div>ì ìˆ˜: <span id="score">0</span></div>
      <div>ë¬´ê¸°: <span id="weapon">Pistol</span> <small id="unlocks" style="opacity:.7"></small></div>
      <div>ì²´ë ¥: <span id="hp">5</span> / <span id="hpmax">5</span></div>
      <div>ë³´ìŠ¤: <span id="boss">-</span></div>
      <div>ë‚œì´ë„: <span id="diff">1.00x</span></div>
      <div>ìƒíƒœ: <span id="status">Survive</span></div>
    </div>

    <div id="overlay" class="overlay">
      <div class="panel">
        <h2>ğŸ‘» ì‚¬ë§í–ˆìŠµë‹ˆë‹¤</h2>
        <p id="finalScore">ìµœì¢… ì ìˆ˜: 0</p>
        <button id="retryBtn" class="btn">ë‹¤ì‹œ ì‹œì‘ (R)</button>
      </div>
    </div>

    <div id="heatbar" class="heatbar"><div id="heatfill" class="heatfill"></div></div>
    <div id="heatlabel" class="heatlabel"></div>
  </div>

<script>
(() => {
  const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
  const ui={score:qs('#score'),weapon:qs('#weapon'),hp:qs('#hp'),hpmax:qs('#hpmax'),boss:qs('#boss'),diff:qs('#diff'),status:qs('#status'),
            overlay:qs('#overlay'),finalScore:qs('#finalScore'),retryBtn:qs('#retryBtn'),unlocks:qs('#unlocks'),
            heatbar:qs('#heatbar'), heatfill:qs('#heatfill'), heatlabel:qs('#heatlabel')};
  function qs(s){return document.querySelector(s)}
  function resize(){const r=canvas.getBoundingClientRect(); canvas.width=r.width; canvas.height=r.height;}
  new ResizeObserver(resize).observe(canvas);

  // images
  const imgPlayer=new Image(); imgPlayer.src='player.png';
  const imgChaser=new Image(); imgChaser.src='enemy.png';
  const imgShooter=new Image(); imgShooter.src='Shooter.png';
  const imgBoss=new Image(); imgBoss.src='boss.png';
  const imgHeal=new Image(); imgHeal.src='heal.png';
  const imgZoey=new Image(); imgZoey.src='zoey.png';
  const imgMira=new Image(); imgMira.src='mira.png';
  const imgAbby=new Image(); imgAbby.src='abby.png';
  const imgBoom=new Image(); imgBoom.src='boom.png';   // ğŸ”¸ Mira í­ë°œ ì´ë¯¸ì§€

  // input
  const keys=new Set(); const mouse={x:0,y:0,down:false};
  addEventListener('keydown',e=>{const k=e.key.toLowerCase(); keys.add(k); if(k==='r'&&state.over) restart();
    if(k==='1') weapon.kind='pistol';
    if(k==='2' && weapon.unlocked.shotgun) weapon.kind='shotgun';
    if(k==='3' && weapon.unlocked.laser) weapon.kind='laser';
    updateWeaponUI();
  });
  addEventListener('keyup',e=>keys.delete(e.key.toLowerCase()));
  canvas.addEventListener('mousedown',ev=>{mouse.down=true; setMouse(ev)});
  addEventListener('mouseup',()=>mouse.down=false);
  canvas.addEventListener('mousemove',setMouse);
  function setMouse(e){const r=canvas.getBoundingClientRect(); mouse.x=e.clientX-r.left; mouse.y=e.clientY-r.top;}

  // state
  const MAX_HP=5;
  const BASE_SPEED=230;
  const state={
    score:0,hp:MAX_HP,wave:1,boss:null,over:false,time:0,invuln:0,diff:1.0,
    shield:null, explosions:[], flashes:[],
    haste:0 // ğŸ”¸ Mira ë²„í”„ íƒ€ì´ë¨¸(ì´ˆ) â€” ë‚¨ëŠ” ë™ì•ˆ ì´ë™ì†ë„ x1.6
  };
  ui.hpmax.textContent=MAX_HP;

  const weapon={kind:'pistol',unlocked:{pistol:true,shotgun:false,laser:false}, heat:0, overheated:false};

  let player={x:canvas.width/2,y:canvas.height/2,r:22,speed:BASE_SPEED,fireCd:0};

  const enemies=[], enemyBullets=[], bullets=[], lasers=[], heals=[], items=[];

  // Enemies
  class EnemyBase{constructor(x,y){this.x=x;this.y=y;this.r=20;this.hp=3;this.dead=false;this.baseSpd=70;} aim(){return Math.atan2(player.y-this.y,player.x-this.x)}}
  class EnemyChaser extends EnemyBase{update(dt){const s=this.baseSpd*state.diff, a=this.aim(); this.x+=Math.cos(a)*s*dt; this.y+=Math.sin(a)*s*dt; if(state.invuln<=0 && dist(this,player)<this.r+player.r){ damagePlayer(1); this.dead=true; }} draw(){ctx.drawImage(imgChaser,this.x-this.r,this.y-this.r,this.r*2,this.r*2);}}
  class EnemyShooter extends EnemyBase{constructor(x,y){super(x,y); this.baseSpd=80; this.hp=2; this.moveT=1.1; this.stopT=0.8; this.timer=this.moveT; this.stopped=false; this.fireCd=0;} update(dt){this.timer-=dt; if(!this.stopped){const s=this.baseSpd*state.diff, a=this.aim(); this.x+=Math.cos(a)*s*dt; this.y+=Math.sin(a)*s*dt; if(this.timer<=0){this.stopped=true; this.timer=this.stopT/Math.min(state.diff,2);} } else { this.fireCd-=dt; if(this.fireCd<=0){const base=this.aim(), sp=0.10+Math.min(0.12,(state.diff-1)*0.04); enemyBullets.push(new EnemyBullet(this.x,this.y,base-sp,230*state.diff)); enemyBullets.push(new EnemyBullet(this.x,this.y,base+sp,230*state.diff)); this.fireCd=0.35/Math.min(state.diff,2.5);} if(this.timer<=0){this.stopped=false; this.timer=this.moveT;} } if(state.invuln<=0 && dist(this,player)<this.r+player.r){ damagePlayer(1); this.dead=true; }} draw(){ctx.drawImage(imgShooter,this.x-this.r,this.y-this.r,this.r*2,this.r*2); if(this.stopped){ctx.save(); ctx.strokeStyle='#b83bff'; ctx.globalAlpha=.8; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(this.x,this.y,this.r+4,0,Math.PI*2); ctx.stroke(); ctx.restore();}}}
  class EnemyAbby extends EnemyBase{constructor(x,y){super(x,y); this.r=22; this.hp=3; this.baseSpd=120; this.mode='wander'; this.dir=Math.random()*Math.PI*2; this.timer=1.2;} update(dt){this.timer-=dt; if(this.mode==='wander'){this.x+=Math.cos(this.dir)*this.baseSpd*dt; this.y+=Math.sin(this.dir)*this.baseSpd*dt; if(this.timer<=0){ this.mode='charge'; this.timer=0.65; this.dir=this.aim(); }} else { this.x+=Math.cos(this.dir)*300*state.diff*dt; this.y+=Math.sin(this.dir)*300*state.diff*dt; if(this.timer<=0){ this.mode='wander'; this.timer=0.8+Math.random()*0.8; this.dir=Math.random()*Math.PI*2; } } this.bound(); if(state.invuln<=0 && dist(this,player)<this.r+player.r){ damagePlayer(1); this.dead=true; }} bound(){ this.x=Math.max(this.r,Math.min(canvas.width-this.r,this.x)); this.y=Math.max(this.r,Math.min(canvas.height-this.r,this.y)); } draw(){ ctx.drawImage(imgAbby,this.x-this.r,this.y-this.r,this.r*2,this.r*2); } }
  class Boss{constructor(){this.x=canvas.width/2; this.y=100; this.r=46; this.baseHp=140; this.hp=Math.round(this.baseHp*state.diff); this.dead=false; this.shootCD=0.9/Math.min(state.diff,2.2); this._t=0;} update(dt){const s=55*state.diff, a=Math.atan2(player.y-this.y,player.x-this.x); this.x+=Math.cos(a)*s*dt; this.y+=Math.sin(a)*s*dt; if(dist(this,player)<this.r+player.r && state.invuln<=0) damagePlayer(2); this._t-=dt; if(this._t<=0){this._t=this.shootCD; if(Math.random()<.5){const base=Math.atan2(player.y-this.y,player.x-this.x); for(let i=-1;i<=1;i++) enemyBullets.push(new EnemyBullet(this.x,this.y,base+i*0.12,220*state.diff));} else {const n=8+Math.floor(state.diff*2); for(let i=0;i<n;i++) enemyBullets.push(new EnemyBullet(this.x,this.y,i*(Math.PI*2/n),180*state.diff));}}} draw(){ctx.drawImage(imgBoss,this.x-this.r,this.y-this.r,this.r*2,this.r*2);}}

  class Bullet{constructor(x,y,a,spd,dmg=1,maxDist=Infinity){this.x=x;this.y=y;this.r=4;this.vx=Math.cos(a)*spd;this.vy=Math.sin(a)*spd;this.dmg=dmg;this.max=maxDist;this.d=0;this.dead=false;} update(dt){const dx=this.vx*dt,dy=this.vy*dt; this.x+=dx; this.y+=dy; this.d+=Math.hypot(dx,dy); if(this.d>=this.max) this.dead=true; if(this.x<0||this.y<0||this.x>canvas.width||this.y>canvas.height) this.dead=true;} draw(){ctx.fillStyle='#73ffdf'; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill();}}
  class EnemyBullet{constructor(x,y,a,spd){this.x=x;this.y=y;this.r=4;this.vx=Math.cos(a)*spd;this.vy=Math.sin(a)*spd;this.dead=false;} update(dt){this.x+=this.vx*dt; this.y+=this.vy*dt; if(this.x<-10||this.y<-10||this.x>canvas.width+10||this.y>canvas.height+10) this.dead=true;} draw(){ctx.fillStyle='#ff5fb1'; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill();}}
  class Heal{ constructor(x,y){this.x=x; this.y=y; this.r=18; this.dead=false;} draw(){ctx.drawImage(imgHeal,this.x-this.r,this.y-this.r,this.r*2,this.r*2);} }

  // Laser (ê°€ì‹œì„± ê°•í™” + ì²« í‹± ë³´ì¥)
  class LaserBeam{
    constructor(x,y,angle){ this.x=x; this.y=y; this.a=angle; this.t=0; this.state='charge'; this.charge=0.32; this.beam=0.24; this.tick=0; this.flash=0.12; }
    update(dt){
      this.t+=dt; const ex=this.x+Math.cos(this.a)*1200, ey=this.y+Math.sin(this.a)*1200;
      if(this.state==='charge'){ if(this.t>=this.charge){ this.state='beam'; this.t=0; this.tick+=0.051; state.flashes.push({x:this.x,y:this.y,t:0}); } }
      else if(this.state==='beam'){
        this.tick+=dt;
        while(this.tick>=0.05){
          this.tick-=0.05;
          enemies.forEach(e=>{ if(lineCircle(this.x,this.y,ex,ey,e.x,e.y,e.r)){ e.hp-=2; if(e.hp<=0){e.dead=true; addScore(10);} }});
          if(state.boss && !state.boss.dead && lineCircle(this.x,this.y,ex,ey,state.boss.x,state.boss.y,state.boss.r)){
            state.boss.hp-=2; if(state.boss.hp<=0){ onBossDead(); addScore(100); }
          }
        }
        if(this.t>=this.beam) this.state='done';
      }
    }
    draw(){
      const ex=this.x+Math.cos(this.a)*1200, ey=this.y+Math.sin(this.a)*1200;
      if(this.state==='charge'){
        ctx.save(); ctx.globalAlpha=.9; ctx.setLineDash([4,5]); ctx.strokeStyle='#b7f4ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(ex,ey); ctx.stroke(); ctx.restore();
      }else if(this.state==='beam'){
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.strokeStyle='#b83bff66'; ctx.lineWidth=18; ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(ex,ey); ctx.stroke(); // outer glow
        ctx.strokeStyle='#d080ff'; ctx.lineWidth=10; ctx.stroke();                                        // main
        ctx.strokeStyle='#eaffff'; ctx.lineWidth=3; ctx.setLineDash([]); ctx.stroke();                    // core
        ctx.restore();
      }
    }
    get dead(){return this.state==='done'}
  }

  // Items + Explosion(boom.png ì‚¬ìš©)
  class ZoeyItem{ constructor(x,y){this.x=x;this.y=y;this.r=18;this.dead=false;} draw(){ctx.drawImage(imgZoey,this.x-this.r,this.y-this.r,this.r*2,this.r*2);} }
  class MiraItem{ constructor(x,y){this.x=x;this.y=y;this.r=18;this.dead=false;} draw(){ctx.drawImage(imgMira,this.x-this.r,this.y-this.r,this.r*2,this.r*2);} }
  class Explosion{
    constructor(x,y){ this.x=x; this.y=y; this.t=0; this.duration=0.6; this.done=false; }
    update(dt){ this.t += dt; if(this.t>=this.duration) this.done=true; }
    draw(){
      const p=this.t/this.duration;                 // 0 â†’ 1
      const size = 220 + p*120;                     // ì ì  ì»¤ì§
      ctx.save();
      ctx.globalAlpha = 1 - p;                      // ì„œì„œíˆ ì‚¬ë¼ì§
      ctx.drawImage(imgBoom, this.x-size/2, this.y-size/2, size, size);
      ctx.restore();
    }
  }

  // helpers
  function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function lineCircle(x1,y1,x2,y2,cx,cy,cr){const dx=x2-x1,dy=y2-y1,l2=dx*dx+dy*dy; let t=((cx-x1)*dx+(cy-y1)*dy)/l2; t=Math.max(0,Math.min(1,t)); const px=x1+t*dx, py=y1+t*dy; return Math.hypot(px-cx,py-cy)<=cr;}

  // spawns
  function spawnEnemyEdge(){
    const edge=Math.floor(Math.random()*4);
    let x=0,y=0;
    if(edge===0){x=-20; y=Math.random()*canvas.height}
    if(edge===1){x=canvas.width+20; y=Math.random()*canvas.height}
    if(edge===2){x=Math.random()*canvas.width; y=-20}
    if(edge===3){x=Math.random()*canvas.width; y=canvas.height+20}
    let choice='chaser';
    const pShooter=Math.min(0.15+(state.diff-1)*0.15,0.6);
    const pAbby = state.score>=500 ? 0.18 : 0.0;
    const r=Math.random();
    if(r<pAbby) choice='abby';
    else if(r<pAbby+pShooter) choice='shooter';
    const e = choice==='abby' ? new EnemyAbby(x,y) : (choice==='shooter' ? new EnemyShooter(x,y) : new EnemyChaser(x,y));
    if(dist(e,player)>160) enemies.push(e);
  }

  function maybeSpawnItems(){
    if(Math.random()<0.0006) heals.push(new Heal(Math.random()*canvas.width,Math.random()*canvas.height));
    if(state.score>=300 && Math.random()<0.0012) items.push(new ZoeyItem(Math.random()*canvas.width,Math.random()*canvas.height));
    if(state.score>=500 && Math.random()<0.0008) items.push(new MiraItem(Math.random()*canvas.width,Math.random()*canvas.height));
  }

  // damage / score
  function addScore(n){ state.score+=n; ui.score.textContent=state.score; }
  function damagePlayer(n){
    if(state.invuln>0) return;
    if(state.shield){ state.shield=null; state.explosions.push(new Explosion(player.x,player.y)); return; }
    state.hp=Math.max(0,state.hp-n); ui.hp.textContent=state.hp; state.invuln=2.0; if(state.hp<=0) gameOver();
  }

  function onBossDead(){ if(!state.boss) return; state.boss.dead=true; state.boss=null; state.wave+=1; state.diff = Math.round(state.diff*1.28*100)/100; ui.diff.textContent=state.diff.toFixed(2)+'x'; ui.boss.textContent='-'; }

  // fire & weapons (ìƒ·ê±´ ê°•í™” ìœ ì§€: ê·¼ì ‘ ë³´ë„ˆìŠ¤ + ë„‰ë°±)
  function fire(){
    if(weapon.kind==='pistol'){ spawnBullet(1,520,Infinity); player.fireCd=0.18; return; }
    if(weapon.kind==='shotgun' && weapon.unlocked.shotgun){
      const base=Math.atan2(mouse.y-player.y,mouse.x-player.x);
      for(let i=0;i<7;i++){ const a=base+(Math.random()-0.5)*0.32; bullets.push(new Bullet(player.x,player.y,a,520,1,260)); }
      player.fireCd=0.32; return;
    }
    if(weapon.kind==='laser' && weapon.unlocked.laser){
      if(weapon.overheated || weapon.heat>=100){ weapon.overheated=true; return; }
      const a=Math.atan2(mouse.y-player.y,mouse.x-player.x);
      lasers.push(new LaserBeam(player.x,player.y,a));
      weapon.heat=Math.min(100, weapon.heat+35);
      if(weapon.heat>=100) weapon.overheated=true;
      player.fireCd=0.55;
      return;
    }
  }
  function spawnBullet(dmg,spd,maxD){ const a=Math.atan2(mouse.y-player.y,mouse.x-player.x); bullets.push(new Bullet(player.x,player.y,a,spd,dmg,maxD)); }

  function update(dt){
    if(state.over) return;
    state.time+=dt; if(state.invuln>0) state.invuln-=dt;

    // Mira ë²„í”„ ê²½ê³¼: ì†ë„ x1.6
    state.haste = Math.max(0, state.haste - dt);
    player.speed = BASE_SPEED * (state.haste>0 ? 1.6 : 1);

    if(state.score>=100) weapon.unlocked.shotgun=true;
    if(state.score>=250) weapon.unlocked.laser=true;
    updateWeaponUI();

    // heat cool & HUD
    const COOL=22;
    if(weapon.heat>0){ weapon.heat=Math.max(0, weapon.heat-COOL*dt); if(weapon.overheated && weapon.heat<=30) weapon.overheated=false; }
    const showHeat = (weapon.kind==='laser' && weapon.unlocked.laser);
    ui.heatbar.style.display = showHeat ? 'block' : 'none';
    if(showHeat){
      ui.heatfill.style.width = Math.min(100, weapon.heat).toFixed(0)+'%';
      ui.heatlabel.textContent = weapon.overheated ? 'Laser HEAT: OVERHEATED' : 'Laser HEAT';
      ui.heatlabel.className = 'heatlabel' + (weapon.overheated ? ' overblink' : '');
    } else {
      ui.heatlabel.textContent='';
    }

    const spawnRate=0.012+(state.diff-1)*0.015;
    if(Math.random()<spawnRate) spawnEnemyEdge();
    maybeSpawnItems();

    enemies.forEach(e=>e.update(dt));
    bullets.forEach(b=>b.update(dt));
    lasers.forEach(l=>l.update(dt));
    enemyBullets.forEach(b=>b.update(dt));
    state.explosions.forEach(ex=>ex.update(dt));
    state.flashes.forEach(f=>f.t+=dt);

    if(state.boss) state.boss.update(dt);

    // bullet collisions + ìƒ·ê±´ ê·¼ì ‘ ë³´ë„ˆìŠ¤/ë„‰ë°±
    for(const b of bullets){
      for(const e of enemies){
        if(!e.dead && !b.dead && dist(e,b)<e.r+b.r){
          let dmg = b.dmg;
          const dToPlayer = dist(e, player);
          if(b.max===260 && dToPlayer<=90) dmg *= 1.5; // close-range bonus
          e.hp -= dmg;
          if(b.max===260){ const dir=Math.atan2(e.y-player.y,e.x-player.x); const kb=80; e.x += Math.cos(dir)*kb*0.06; e.y += Math.sin(dir)*kb*0.06; }
          b.dead=true;
          if(e.hp<=0){ e.dead=true; addScore(10); }
        }
      }
      if(state.boss && !b.dead && !state.boss.dead && dist(state.boss,b)<state.boss.r+b.r){
        state.boss.hp-=b.dmg; b.dead=true; if(state.boss.hp<=0){ onBossDead(); addScore(100); }
      }
    }
    for(const eb of enemyBullets){ if(dist(eb,player)<eb.r+player.r){ eb.dead=true; damagePlayer(1); } }

    // í”½ì—… ì²˜ë¦¬
    heals.forEach(h=>{ if(dist(h,player)<h.r+player.r){ h.dead=true; state.hp=Math.min(MAX_HP,state.hp+1); ui.hp.textContent=state.hp; }});
    for(const it of items){
      if(dist(it,player)<it.r+player.r){
        it.dead=true;
        if(it instanceof ZoeyItem){
          state.shield={angle:0,dist:28};
        }else if(it instanceof MiraItem){
          triggerMiraExplosion(player.x,player.y); // ğŸ”¸ í­ë°œ + ê°€ì† ë²„í”„
        }
      }
    }

    cleanup(bullets); cleanup(enemies); cleanup(lasers); cleanup(enemyBullets); cleanup(heals); cleanup(items);
    for(let i=state.explosions.length-1;i>=0;i--) if(state.explosions[i].done) state.explosions.splice(i,1);
    for(let i=state.flashes.length-1;i>=0;i--) if(state.flashes[i].t>0.12) state.flashes.splice(i,1);

    if(!state.boss && state.score>=state.wave*500){ state.boss=new Boss(); ui.boss.textContent='ë“±ì¥'; }

    // movement
    let dx=(keys.has('d')?1:0)-(keys.has('a')?1:0);
    let dy=(keys.has('s')?1:0)-(keys.has('w')?1:0);
    const len=Math.hypot(dx,dy)||1;
    player.x+=dx/len*player.speed*dt; player.y+=dy/len*player.speed*dt;
    player.x=clamp(player.x,player.r,canvas.width-player.r); player.y=clamp(player.y,player.r,canvas.height-player.r);

    player.fireCd-=dt; if(mouse.down && player.fireCd<=0) fire();
    ui.status.textContent = state.over ? 'Game Over' : (state.boss ? 'Boss' : 'Survive');
  }

  // ğŸ”¸ Mira í­ë°œ ë¡œì§ (ë°˜ê²½ 200, ë³´ìŠ¤ í”¼í•´ ì—†ìŒ)
  function triggerMiraExplosion(x,y){
    state.explosions.push(new Explosion(x,y));
    enemies.forEach(e=>{ if(dist({x,y},e) < 200){ e.dead=true; addScore(10); } });
    state.haste = 1.0; // 1ì´ˆ ê°€ì†
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    enemies.forEach(e=>e.draw());
    if(state.boss) state.boss.draw();
    bullets.forEach(b=>b.draw());
    enemyBullets.forEach(b=>b.draw());
    heals.forEach(h=>h.draw());
    items.forEach(i=>i.draw());
    lasers.forEach(l=>l.draw());
    state.explosions.forEach(ex=>ex.draw());

    // muzzle flash when laser fires
    state.flashes.forEach(f=>{
      ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.globalAlpha=1 - (f.t/0.12);
      ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.arc(f.x,f.y,18*(1+f.t*3),0,Math.PI*2); ctx.fill();
      ctx.restore();
    });

    // player blink when invuln
    const blink = state.invuln>0 ? (Math.sin(state.time*20)>0?0.45:1) : 1;
    ctx.save(); ctx.globalAlpha=blink; ctx.drawImage(imgPlayer,player.x-player.r,player.y-player.r,player.r*2,player.r*2); ctx.restore();

    // shield orbit (Zoey)
    if(state.shield){ state.shield.angle += 6/60; const sx = player.x + Math.cos(state.shield.angle)*state.shield.dist; const sy = player.y + Math.sin(state.shield.angle)*state.shield.dist; ctx.drawImage(imgZoey, sx-14, sy-14, 28, 28); }

    // HP & Boss bars
    const pad=14; const pRatio = state.hp/MAX_HP;
    ctx.fillStyle='#0f3a2a'; ctx.globalAlpha=.35; ctx.fillRect(pad,pad,canvas.width-pad*2,10); ctx.globalAlpha=1;
    const grad = ctx.createLinearGradient(pad,0,pad+(canvas.width-pad*2)*pRatio,0); grad.addColorStop(0,'#73ffdf'); grad.addColorStop(1,'#2dffc4'); ctx.fillStyle=grad; ctx.fillRect(pad,pad,(canvas.width-pad*2)*pRatio,10);
    if(state.boss){ const bRatio = Math.max(0,Math.min(1, state.boss.hp/Math.round(140*state.diff))); ctx.fillStyle='#3b104f'; ctx.globalAlpha=.35; ctx.fillRect(pad,pad+16,canvas.width-pad*2,10); ctx.globalAlpha=1; const bgrad = ctx.createLinearGradient(pad,0,pad+(canvas.width-pad*2)*bRatio,0); bgrad.addColorStop(0,'#d080ff'); bgrad.addColorStop(1,'#b018ff'); ctx.fillStyle=bgrad; ctx.fillRect(pad,pad+16,(canvas.width-pad*2)*bRatio,10); }
  }

  function cleanup(arr){ for(let i=arr.length-1;i>=0;i--) if(arr[i].dead) arr.splice(i,1) }

  function gameOver(){ state.over=true; ui.overlay.style.display='flex'; ui.finalScore.textContent='ìµœì¢… ì ìˆ˜: '+state.score; }
  function restart(){
    state.score=0; state.hp=MAX_HP; state.wave=1; state.boss=null; state.over=false; state.time=0; state.invuln=0; state.diff=1.0; state.shield=null; state.explosions.length=0; state.flashes.length=0; state.haste=0;
    enemies.length=0; bullets.length=0; lasers.length=0; enemyBullets.length=0; heals.length=0; items.length=0;
    player.x=canvas.width/2; player.y=canvas.height/2; player.fireCd=0; player.speed=BASE_SPEED;
    weapon.kind='pistol'; weapon.unlocked={pistol:true,shotgun:false,laser:false}; weapon.heat=0; weapon.overheated=false;
    ui.overlay.style.display='none'; ui.score.textContent='0'; ui.hp.textContent=String(MAX_HP); ui.weapon.textContent='Pistol'; ui.boss.textContent='-'; ui.diff.textContent='1.00x';
    updateWeaponUI(); ui.heatbar.style.display='none'; ui.heatlabel.textContent='';
  }
  ui.retryBtn.addEventListener('click',restart);

  function updateWeaponUI(){
    ui.weapon.textContent = weapon.kind[0].toUpperCase()+weapon.kind.slice(1);
    ui.unlocks.textContent = ` (1:Pistol Â· 2:Shotgun${weapon.unlocked.shotgun?'âœ…':'ğŸ”’'} Â· 3:Laser${weapon.unlocked.laser?'âœ…':'ğŸ”’'})`;
  }

  let last=0; function loop(t){const dt=(t-last)/1000; last=t; update(Math.min(dt,0.033)); draw(); requestAnimationFrame(loop)} requestAnimationFrame(loop);
})();
</script>
</body>
</html>
