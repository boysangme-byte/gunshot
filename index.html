<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>악령사냥</title>
  <style>
    :root { --bg:#0a0014; --panel:#150b2c; --line:#3a2360; --text:#e9d7ff; --accent:#d080ff; --danger:#ff4fa0; --good:#73ffdf; }
    *{ box-sizing:border-box; }
    body { margin:0; background: radial-gradient(900px 600px at 70% 20%, #1a0038, var(--bg)); color:var(--text);
           font-family: "Noto Sans KR", system-ui, sans-serif; display:grid; place-items:center; min-height:100vh; }
    .stage { position:relative; width:100%; max-width:960px; }
    #game { width:100%; aspect-ratio:16/9; border:2px solid var(--line); border-radius:12px; background:#000; display:block; touch-action:none; }
    .hud { display:flex; gap:12px; margin-top:6px; font-size:14px; flex-wrap:wrap; }
    .hud div { background:rgba(255,255,255,0.05); border:1px solid var(--line); padding:6px 10px; border-radius:8px; }
    .title { font-weight:900; font-size:20px; margin:10px 0 8px; color:var(--accent); text-shadow:0 0 8px var(--accent); display:flex; align-items:center; gap:8px; }
    .controls { font-size:13px; opacity:.8; margin-top:4px; }
    /* overlay */
    .overlay { position:absolute; inset:0; display:none; align-items:center; justify-content:center; }
    .panel { background:#120626ee; border:1px solid var(--line); border-radius:16px; padding:22px; text-align:center; box-shadow:0 10px 30px #0008; }
    .panel h2 { margin:0 0 8px; color:#ffd1ff; text-shadow:0 0 12px #a03cff; }
    .btn { background:#2a1658; color:#fff; border:1px solid #5b3db3; padding:10px 16px; border-radius:10px; cursor:pointer; }
    .btn:hover{ filter:brightness(1.08); }
  </style>
</head>
<body>
  <div class="stage">
    <div class="title">🎮 악령사냥 <small style="opacity:.7;font-weight:600;">v5</small></div>
    <canvas id="game"></canvas>

    <!-- Game Over Overlay -->
    <div id="overlay" class="overlay">
      <div class="panel">
        <h2>👻 사망했습니다</h2>
        <p id="finalScore">최종 점수: 0</p>
        <button id="retryBtn" class="btn">다시 시작 (R)</button>
      </div>
    </div>

    <div class="hud">
      <div>점수: <span id="score">0</span></div>
      <div>무기: <span id="weapon">Pistol</span> <small id="unlocks" style="opacity:.7"></small></div>
      <div>체력: <span id="hp">5</span> / <span id="hpmax">5</span></div>
      <div>보스: <span id="boss">-</span></div>
      <div>난이도: <span id="diff">1.00x</span></div>
      <div>상태: <span id="status">Survive</span></div>
    </div>
    <div class="controls">WASD 이동 · 마우스 조준/클릭 발사 · Shift 대시 · <b>무기 숫자 1/2/3 전환</b> (100점: 샷건, 250점: 레이저 해금)</div>
  </div>

<script>
(() => {
  const canvas=document.getElementById("game"), ctx=canvas.getContext("2d");
  const ui={score:document.getElementById("score"), weapon:document.getElementById("weapon"),
            hp:document.getElementById("hp"), hpmax:document.getElementById("hpmax"), boss:document.getElementById("boss"), status:document.getElementById("status"),
            overlay:document.getElementById("overlay"), finalScore:document.getElementById("finalScore"),
            retryBtn:document.getElementById("retryBtn"), unlocks:document.getElementById("unlocks"), diff:document.getElementById("diff")};
  function resize(){const r=canvas.getBoundingClientRect(); canvas.width=r.width; canvas.height=r.height;}
  new ResizeObserver(resize).observe(canvas);

  // Load images
  const imgPlayer=new Image(); imgPlayer.src="player.png";
  const imgEnemy=new Image(); imgEnemy.src="enemy.png";
  const imgBoss=new Image(); imgBoss.src="boss.png";
  const imgHeal=new Image(); imgHeal.src="heal.png";

  // input
  const keys=new Set(); const mouse={x:0,y:0,down:false};
  window.addEventListener("keydown",e=>{
    const k=e.key.toLowerCase();
    keys.add(k);
    if(k==='r' && state.over) restart();
    if(k==='1'){ weapon.kind='pistol'; }
    if(k==='2' && weapon.unlocked.shotgun){ weapon.kind='shotgun'; }
    if(k==='3' && weapon.unlocked.laser){ weapon.kind='laser'; }
    updateWeaponUI();
  });
  window.addEventListener("keyup",e=>{keys.delete(e.key.toLowerCase());});
  canvas.addEventListener("mousedown",()=>mouse.down=true);
  window.addEventListener("mouseup",()=>mouse.down=false);
  canvas.addEventListener("mousemove",e=>{const r=canvas.getBoundingClientRect(); mouse.x=e.clientX-r.left; mouse.y=e.clientY-r.top;});

  // state
  const MAX_HP = 5;
  const state={score:0, hp:MAX_HP, wave:1, boss:null, over:false, time:0, invuln:1.2, diff:1.0};
  ui.hpmax.textContent = MAX_HP;

  let player={x:400,y:260,r:22,speed:230,fireCd:0,dash:0};
  const bullets=[], enemies=[], heals=[];
  const lasers=[]; // visible laser beams
  const enemyBullets=[]; // boss bullets

  const weapon = {
    kind:'pistol',
    unlocked:{ pistol:true, shotgun:false, laser:false }
  };

  // entities
  class Enemy{
    constructor(x,y){ this.x=x; this.y=y; this.r=20; this.baseSpd=70; this.hp=3; this.dead=false; }
    update(dt){
      const spd=this.baseSpd*state.diff;
      const a=Math.atan2(player.y-this.y, player.x-this.x);
      this.x += Math.cos(a)*spd*dt;
      this.y += Math.sin(a)*spd*dt;
      if(!state.over && state.invuln<=0 && dist(this, player) < this.r + player.r){ hitPlayer(); this.dead=true; }
    }
    draw(){ ctx.drawImage(imgEnemy, this.x-this.r, this.y-this.r, this.r*2, this.r*2); }
  }
  class Boss{
    constructor(){
      this.x=canvas.width/2; this.y=90; this.r=46;
      this.baseHp=140; this.hp=Math.round(this.baseHp*state.diff); this.dead=false;
      this.shootCD=0.9/Math.min(state.diff,2.2); // faster at higher diff (cap)
      this._timer=0;
    }
    update(dt){
      const spd=55*state.diff; // move a bit faster than v4
      const a=Math.atan2(player.y-this.y, player.x-this.x);
      this.x += Math.cos(a)*spd*dt; this.y += Math.sin(a)*spd*dt;
      if(!state.over && dist(this, player) < this.r + player.r){ hitPlayer(2); }
      // shooting patterns
      this._timer -= dt;
      if(this._timer<=0){
        this._timer = this.shootCD;
        if(Math.random()<0.5){
          // aimed triple shot
          const base = Math.atan2(player.y-this.y, player.x-this.x);
          for(let i=-1;i<=1;i++){
            enemyBullets.push(new EnemyBullet(this.x,this.y, base + i*0.12, 220*state.diff));
          }
        } else {
          // radial burst
          const n = 8 + Math.floor(state.diff*2);
          for(let i=0;i<n;i++){
            enemyBullets.push(new EnemyBullet(this.x,this.y, i*(Math.PI*2/n), 180*state.diff));
          }
        }
      }
    }
    draw(){ ctx.drawImage(imgBoss, this.x-this.r, this.y-this.r, this.r*2, this.r*2); }
  }
  class Bullet{
    constructor(x,y,a,speed,dmg=1){ this.x=x; this.y=y; this.r=4; this.vx=Math.cos(a)*speed; this.vy=Math.sin(a)*speed; this.dmg=dmg; this.dead=false; }
    update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; if(this.x<0||this.y<0||this.x>canvas.width||this.y>canvas.height) this.dead=true; }
    draw(){ ctx.fillStyle="#73ffdf"; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); }
  }
  class EnemyBullet{
    constructor(x,y,a,speed){ this.x=x; this.y=y; this.r=4; this.vx=Math.cos(a)*speed; this.vy=Math.sin(a)*speed; this.dead=false; }
    update(dt){ this.x+=this.vx*dt; this.y+=this.vy*dt; if(this.x<-10||this.y<-10||this.x>canvas.width+10||this.y>canvas.height+10) this.dead=true; }
    draw(){ ctx.fillStyle="#ff5fb1"; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fill(); }
  }
  class Heal{ constructor(x,y){ this.x=x; this.y=y; this.r=18; this.dead=false; } draw(){ ctx.drawImage(imgHeal, this.x-this.r, this.y-this.r, this.r*2, this.r*2); } }
  class LaserBeam{
    constructor(x,y,angle){ this.x=x; this.y=y; this.a=angle; this.t=0; this.life=0.25; }
    update(dt){
      this.t += dt;
      const endX = this.x + Math.cos(this.a)*1200;
      const endY = this.y + Math.sin(this.a)*1200;
      enemies.forEach(e=>{
        if(lineCircle(this.x,this.y,endX,endY,e.x,e.y,e.r)){ e.hp -= 2; if(e.hp<=0){ e.dead=true; addScore(10); } }
      });
      if(state.boss && !state.boss.dead && lineCircle(this.x,this.y,endX,endY,state.boss.x,state.boss.y,state.boss.r)){
        state.boss.hp -= 2; if(state.boss.hp<=0){ onBossDead(); addScore(100); }
      }
    }
    draw(){
      const endX = this.x + Math.cos(this.a)*1200;
      const endY = this.y + Math.sin(this.a)*1200;
      ctx.save();
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='#d080ff'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(endX,endY); ctx.stroke();
      ctx.strokeStyle='#b83bff66'; ctx.lineWidth=12; ctx.stroke();
      ctx.restore();
    }
    get dead(){ return this.t >= this.life; }
  }

  // helpers
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function lineCircle(x1,y1,x2,y2,cx,cy,cr){
    const dx=x2-x1, dy=y2-y1, l2=dx*dx+dy*dy;
    let t=((cx-x1)*dx + (cy-y1)*dy)/l2; t=Math.max(0,Math.min(1,t));
    const px=x1+t*dx, py=y1+t*dy; return Math.hypot(px-cx, py-cy) <= cr;
  }

  // game core
  function spawnEnemyEdge(){
    const edge=Math.floor(Math.random()*4);
    let x=0,y=0;
    if(edge===0){ x=-20; y=Math.random()*canvas.height; }
    if(edge===1){ x=canvas.width+20; y=Math.random()*canvas.height; }
    if(edge===2){ x=Math.random()*canvas.width; y=-20; }
    if(edge===3){ x=Math.random()*canvas.width; y=canvas.height+20; }
    const e=new Enemy(x,y);
    if(dist(e,player) > 160) enemies.push(e);
  }

  function hitPlayer(dmg=1){
    state.hp = Math.max(0, state.hp - dmg);
    ui.hp.textContent = state.hp;
    state.invuln = 0.4;
    if(state.hp<=0) gameOver();
  }

  function fire(){
    if(weapon.kind==='pistol'){
      spawnBullet(1,520);
      player.fireCd = 0.18;
      return;
    }
    if(weapon.kind==='shotgun' && weapon.unlocked.shotgun){
      const base = Math.atan2(mouse.y-player.y, mouse.x-player.x);
      for(let i=0;i<6;i++){
        const a = base + (Math.random()-0.5)*0.35;
        bullets.push(new Bullet(player.x,player.y,a,520,1));
      }
      player.fireCd = 0.34;
      return;
    }
    if(weapon.kind==='laser' && weapon.unlocked.laser){
      const a = Math.atan2(mouse.y-player.y, mouse.x-player.x);
      lasers.push(new LaserBeam(player.x, player.y, a));
      player.fireCd = 0.5;
      return;
    }
  }
  function spawnBullet(dmg,speed){ const a=Math.atan2(mouse.y-player.y, mouse.x-player.x); bullets.push(new Bullet(player.x,player.y,a,speed,dmg)); }

  function addScore(n){ state.score += n; ui.score.textContent = state.score; }

  function onBossDead(){
    if(!state.boss) return;
    state.boss.dead = true;
    state.boss = null;
    state.wave += 1;
    // Stronger difficulty scaling
    state.diff = Math.round(state.diff*1.28*100)/100; // was 1.18
    ui.diff.textContent = state.diff.toFixed(2)+'x';
    ui.boss.textContent='-';
  }

  function update(dt){
    if(state.over) return;
    state.time += dt; if(state.invuln>0) state.invuln -= dt;

    // unlock progression
    if(state.score>=100) weapon.unlocked.shotgun = true;
    if(state.score>=250) weapon.unlocked.laser = true;
    updateWeaponUI();

    // enemy spawn: scales with difficulty (stronger)
    const baseSpawn = 0.012 + (state.diff-1)*0.015;
    if(Math.random() < baseSpawn) spawnEnemyEdge();

    enemies.forEach(e=>e.update(dt));
    bullets.forEach(b=>b.update(dt));
    lasers.forEach(l=>l.update(dt));
    enemyBullets.forEach(eb=>eb.update(dt));

    // bullet collisions (player bullets)
    for(const b of bullets){
      for(const e of enemies){
        if(!e.dead && !b.dead && dist(e,b) < e.r + b.r){
          e.hp -= b.dmg; b.dead = true;
          if(e.hp<=0){ e.dead=true; addScore(10); }
        }
      }
      if(state.boss && !b.dead && !state.boss.dead && dist(state.boss,b) < state.boss.r + b.r){
        state.boss.hp -= b.dmg; b.dead=true;
        if(state.boss.hp<=0){ onBossDead(); addScore(100); }
      }
    }
    // boss bullets -> player
    for(const eb of enemyBullets){
      if(!state.over && dist(eb, player) < eb.r + player.r){ eb.dead=true; hitPlayer(1); }
    }

    // cleanup
    for(let i=bullets.length-1;i>=0;i--){ if(bullets[i].dead) bullets.splice(i,1); }
    for(let i=enemies.length-1;i>=0;i--){ if(enemies[i].dead) enemies.splice(i,1); }
    for(let i=lasers.length-1;i>=0;i--){ if(lasers[i].dead) lasers.splice(i,1); }
    for(let i=enemyBullets.length-1;i>=0;i--){ if(enemyBullets[i].dead) enemyBullets.splice(i,1); }

    // boss spawn: 500*n score
    if(!state.boss && state.score >= state.wave*500){ state.boss = new Boss(); ui.boss.textContent='등장'; }

    // heals: LOWER frequency
    if(Math.random()<0.0006) heals.push(new Heal(Math.random()*canvas.width, Math.random()*canvas.height));
    for(const h of heals){ if(dist(h,player) < h.r + player.r){ h.dead=true; state.hp=Math.min(MAX_HP, state.hp+1); ui.hp.textContent=state.hp; } }
    for(let i=heals.length-1;i>=0;i--){ if(heals[i].dead) heals.splice(i,1); }

    // player movement
    let dx=(keys.has('d')?1:0)-(keys.has('a')?1:0);
    let dy=(keys.has('s')?1:0)-(keys.has('w')?1:0);
    const len=Math.hypot(dx,dy)||1;
    player.x += (dx/len)*player.speed*dt;
    player.y += (dy/len)*player.speed*dt;
    player.x = clamp(player.x, player.r, canvas.width-player.r);
    player.y = clamp(player.y, player.r, canvas.height-player.r);

    // fire
    player.fireCd -= dt;
    if(mouse.down && player.fireCd<=0){ fire(); }

    ui.status.textContent = state.over ? 'Game Over' : (state.boss ? 'Boss' : 'Survive');
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    enemies.forEach(e=>e.draw());
    if(state.boss) state.boss.draw();
    bullets.forEach(b=>b.draw());
    enemyBullets.forEach(eb=>eb.draw());
    heals.forEach(h=>h.draw());
    lasers.forEach(l=>l.draw());
    ctx.drawImage(imgPlayer, player.x-player.r, player.y-player.r, player.r*2, player.r*2);

    // HP bars
    const pad=14;
    const pRatio = state.hp / MAX_HP;
    ctx.fillStyle='#0f3a2a'; ctx.globalAlpha=0.35; ctx.fillRect(pad, pad, canvas.width-pad*2, 10); ctx.globalAlpha=1;
    const grad = ctx.createLinearGradient(pad,0, pad+(canvas.width-pad*2)*pRatio, 0);
    grad.addColorStop(0,'#73ffdf'); grad.addColorStop(1,'#2dffc4');
    ctx.fillStyle=grad; ctx.fillRect(pad, pad, (canvas.width-pad*2)*pRatio, 10);
    if(state.boss){
      const bRatio = Math.max(0, Math.min(1, state.boss.hp / Math.round(140*state.diff)));
      ctx.fillStyle='#3b104f'; ctx.globalAlpha=0.35; ctx.fillRect(pad, pad+16, canvas.width-pad*2, 10); ctx.globalAlpha=1;
      const bgrad = ctx.createLinearGradient(pad,0, pad+(canvas.width-pad*2)*bRatio, 0);
      bgrad.addColorStop(0,'#d080ff'); bgrad.addColorStop(1,'#b018ff');
      ctx.fillStyle=bgrad; ctx.fillRect(pad, pad+16, (canvas.width-pad*2)*bRatio, 10);
    }
  }

  function gameOver(){
    state.over = true;
    ui.overlay.style.display = 'flex';
    ui.finalScore.textContent = '최종 점수: ' + state.score;
  }
  function restart(){
    state.score=0; state.hp=MAX_HP; state.wave=1; state.boss=null; state.over=false; state.time=0; state.invuln=1.2; state.diff=1.0;
    enemies.length=0; bullets.length=0; heals.length=0; lasers.length=0; enemyBullets.length=0;
    player.x=canvas.width/2; player.y=canvas.height/2; player.fireCd=0; weapon.kind='pistol'; weapon.unlocked={pistol:true,shotgun:false,laser:false};
    ui.overlay.style.display='none'; ui.score.textContent='0'; ui.hp.textContent=String(MAX_HP); ui.weapon.textContent='Pistol'; ui.boss.textContent='-'; ui.diff.textContent='1.00x';
    updateWeaponUI();
  }
  ui.retryBtn.addEventListener('click', restart);

  function updateWeaponUI(){
    ui.weapon.textContent = weapon.kind.charAt(0).toUpperCase()+weapon.kind.slice(1);
    const labels = [];
    labels.push('1:Pistol');
    labels.push('2:Shotgun' + (weapon.unlocked.shotgun?'✅':'🔒'));
    labels.push('3:Laser' + (weapon.unlocked.laser?'✅':'🔒'));
    ui.unlocks.textContent = ' ('+labels.join(' · ')+')';
  }

  // loop
  let last=0; function loop(t){ const dt = (t-last)/1000; last=t; update(Math.min(dt,0.033)); draw(); requestAnimationFrame(loop); }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
